type TreasuryEvent = record {};
type TokenIdentifierBlob__1 = blob;
type TokenIdentifierBlob = blob;
type Timestamp = int;
type Time = int;
type Share = nat16;
type PwrEvent = variant {transaction: EventFungibleTransaction;};
type NftEvent = 
 variant {
   burn:
    record {
      created: Timestamp;
      memo: Memo;
      token: TokenIdentifierBlob;
      user: AccountIdentifier;
    };
   mint: record {
           created: Timestamp;
           token: TokenIdentifierBlob;
         };
   purchase: NFTPurchase;
   socket:
    record {
      created: Timestamp;
      plug: TokenIdentifierBlob;
      socket: TokenIdentifierBlob;
    };
   transaction:
    record {
      created: Timestamp;
      from: AccountIdentifier;
      memo: Memo;
      to: AccountIdentifier;
      token: TokenIdentifierBlob;
    };
   unsocket:
    record {
      created: Timestamp;
      plug: TokenIdentifierBlob;
      socket: TokenIdentifierBlob;
    };
   use:
    record {
      created: Timestamp;
      memo: Memo;
      token: TokenIdentifierBlob;
      use: ItemUse;
      user: AccountIdentifier;
    };
 };
type NFTPurchase = 
 record {
   affiliate: opt record {
                    address: AccountIdentifier__1;
                    share: Share;
                  };
   amount: ICP;
   author: record {
             address: AccountIdentifier__1;
             share: Share;
           };
   buyer: AccountIdentifier__1;
   created: Time;
   ledgerBlock: BlockIndex;
   marketplace: opt record {
                      address: AccountIdentifier__1;
                      share: Share;
                    };
   purchaseAccount: AccountIdentifier__1;
   seller: AccountIdentifier__1;
   token: TokenIdentifierBlob__1;
 };
type Memo = nat64;
type ListResponse = vec opt Event;
type ListRequest = 
 record {
   from: EventIndex;
   to: EventIndex;
 };
type ItemUse = 
 variant {
   consumable: record {useId: CustomId;};
   cooldown: record {
               duration: Cooldown;
               useId: CustomId;
             };
 };
type InfoResponse = 
 record {
   previous: opt principal;
   total: EventIndex;
 };
type ICP = record {e8s: nat64;};
type EventInfo = 
 variant {
   anv: AnvEvent;
   nft: NftEvent;
   pwr: PwrEvent;
   treasury: TreasuryEvent;
 };
type EventIndex = nat32;
type EventFungibleTransaction = 
 record {
   amount: Balance;
   created: Timestamp;
   from: AccountIdentifier;
   memo: Memo;
   to: AccountIdentifier;
   token: TokenIdentifierBlob;
 };
type Event = 
 record {
   hash: blob;
   info: EventInfo;
 };
type CustomId = nat64;
type Cooldown = nat32;
type Config = 
 record {
   account: vec principal;
   anv: principal;
   history: principal;
   nft: vec principal;
   nft_avail: vec principal;
   pwr: principal;
   router: principal;
   slot: nat;
   treasury: principal;
 };
type Class = 
 service {
   add: (EventInfo) -> (AddResponse);
   config_set: (Config) -> ();
   info: () -> (InfoResponse) query;
   list: (ListRequest) -> (ListResponse) query;
 };
type BlockIndex = nat64;
type Balance = nat64;
type AnvEvent = variant {transaction: EventFungibleTransaction;};
type AddResponse = 
 variant {
   err: variant {NotLegitimateCaller;};
   ok;
 };
type AccountIdentifier__1 = blob;
type AccountIdentifier = blob;
service : () -> Class
